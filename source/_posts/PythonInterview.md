---
title: Python面试相关
date: 2020-04-22 16:29:32
author: Kevin Feng
tags:
- python
- 面试
---
本文主要介绍python中与面试相关的内容
<!--more-->
## 装饰器

## 迭代器/生成器
- 调用iter()时 会返回一个拥有next()函数的对象,这个对象就是迭代器
- 在使用```for sth in Iterator:```的时候就会自动调用iter()函数 然后返回迭代器
- 所有生成器都是迭代器,因为他可以迭代
- 生成器使用yield,每次yield相当于是一个断点, 当遇到yield后这个生成器自动停止并保留所有状态,然后返回yield后的值, 当使用next()函数获取下一个值的时候函数就会从上一次yield之后向下运行到下一个yield. 都运行玩了会抛出StopIteration的异常,但是自己手写的话建议使用return
- 迭代器会占用更多空间,比如一个超大的数组如果用[i for i in range(10000)]]的话会创建一个数组,但是生成器会一个一个计算,计算是在调用next()的时候而不是预先创建好,这个可以节省大量的内存.
  
## 内存管理
### 1. 引用计数
对所有的对象采用引用计数的方式,如果有变量使用了该地址,那么这个地址的计数就加一,如果这个变量不用了 就减一, 如果一个对象的引用计数为0就可以销毁了 因为没有人会用他了
### 2. 循环引用
引用计数会导致循环引用的问题
比如两个ListNode A,B 他俩的next分别指向对方,那么当他俩同时销毁的时候,引用数依然在1, 但这个时候确实没有人指向他们了. 所以还有另外一个机制是定时扫描有没有不能被指向的对象,如果有的话一样销毁
### 内存池机制
1. C中不能频繁调用malloc以及free. 所以python如果再1-256字节之间会使用自己的内存管理系统,之外的就直接使用malloc,每次malloc分别256bits的内存
2. 对于整块内存如果都没用了才销毁,否则将保留,同时如果块被保留了很多轮,那么下一次就不会检查这一块(思想: 如果一个内存长期有用的话,那么他可能会持续更长的时间)

## 多进程
- MultiProcessing 模块

## Python的IPC(进程间通信)
使用MultiProcessing.Queue()
Queue.put() 写入
Queue.get() 读取
## 为什么有GIL
- CPython本不是线程安全的,所以需要保障原生多线程不会并发执行代码
- GIL在python3.x 中是计时的,时间一到就自动释放
### 使用GIL相比在管理锁中更快的原因
- 单线程上更快
- I/O密集的多线程更快
- CPU密集上在C库中更快
- 编写 C 扩展会更容易：除法你手动指定，否则不会发生 Python 线程切换的问题。
- 封装 C 库变得更容易，因为不需要考虑线程安全问题。如果该库不是线程安全的，你只需要保证调用时 GIL 是锁定的。
### 即使有GIL但是还是可以多线程
- 首先多进程不影响,所以CPU密集型还是可以使用多线程来解决(每个进程一个GIL)
- GIL虽然只是保证了只有一个线程再用,但是对于IO密集型来说,依然可以使用多线程,当程序等待用户输入的时候完全可以切换到另一个线程上进行计算.